package main

import "fmt"

/*

629. K个逆序对数组
给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

示例 1:

输入: n = 3, k = 0
输出: 1
解释:
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
示例 2:

输入: n = 3, k = 1
输出: 2
解释:
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
说明:

 n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。

 */

func main() {
	fmt.Println(kInversePairs(3,2))
}

func kInversePairs(n int, k int) int {
	dp := make([][]int,n+1)
	for i := 0;i<len(dp);i++ {
		dp[i] = make([]int,k + 1)
	}
	for i := 0;i<len(dp);i++ {
		dp[i][0] = 1
	}
	for j := 1;j<len(dp[0]);j++ {
		dp[1][j] = 0
	}

	const M = 1000000007
	for i := 2;i<len(dp);i++ {
		for j := 1;j<len(dp[0]) && j <= i*(i-1)/2;j ++ {
			if j >= i {
				dp[i][j] = (dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i] + M) % M
			} else {
				dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % M
			}
		}
	}

	return dp[n][k]
}

/*

我们用 f(i, j) 表示数字 [1 .. i] 的排列中恰好包含 j 个逆序对的个数。在状态转移时，我们考虑数 i 放置的位置与逆序对个数的关系。我们在数字 [1 .. i - 1] 组成的排列中放入 i 时，有 i 种放置方法：如果将 i 放在最后，则逆序对数量不变；如果将 i 放在倒数第二个，则逆序对数量增加 1；如果将 i 放在第一个，则逆序对数量增加 i - 1。这是因为 i 是 [1 .. i] 中的最大值，因此将它放置在 [1 .. i - 1] 的排列中的任意一个位置，它都会与在它之后的那些数形成逆序对。如果它后面有 k 个数，则会形成 k 个逆序对。

因此我们可以写出状态转移方程：


f(i, j) = f(i - 1, j) + f(i - 1, j - 1) + ... + f(i - 1, j - i + 1)
边界条件为:


f(i, j0) = 0 if j0 < 0
f(0, 0) = 1
这个动态规划的时间复杂度为 O(N^2*K)，因此我们需要继续优化。可以发现，状态转移方程中的右侧是一段连续的和，我们将 j 变为 j - 1，有：


f(i, j - 1) = f(i - 1, j - 1) + f(i - 1, j - 2) + ... + f(i - 1, j - i)
将 f(i, j) 与 f(i, j - 1) 相比较，可以得到：


f(i, j) - f(i - 1, j) = f(i, j - 1) - f(i - 1, j - i)
==> f(i, j) = f(i, j - 1) + f(i - 1, j) - f(i - 1, j - i)


// dp[i][j] 表示 数字1到i的排列中包含j个逆序对，这样的组合的个数
// i是最大的数字，它放在某个位置，那它后面的数肯定比它小

// dp[i][j] = dp[i-1][j] + ... + dp[i-1][j-(i-1)]
// dp[i][j-1] = dp[i-1][j-1] + ... + dp[i-1][j-i]

// dp[i][j] - dp[i][j-1] = dp[i-1][j] - dp[i-1][j-i]
// dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]

// dp[i][0] = 1 不包含逆序对的，肯定就是按升序排列的

// 1个数字肯对那个只有0个逆序对，这样的组合个数是1
// dp[1][0] = 1
// dp[1][1] = 0

// n个数字，两两组和，组合数的公式为，Cn2 = n!/(2! * (n-2)!) = n*(n-1)/2
// 所以i个数字，j最大为i*(i-1)/2

public class Solution {
    public int kInversePairs(int n, int k) {
        int[][] dp = new int[n + 1][k + 1];
        int M = 1000000007;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k && j <= i * (i - 1) / 2; j++) {
                if (i == 1 && j == 0) {
                    dp[i][j] = 1;
                    break;
                } else if (j == 0)
                    dp[i][j] = 1;
                else {
                    int val = (dp[i - 1][j] + M - ((j - i) >= 0 ? dp[i - 1][j - i] : 0)) % M;
                    dp[i][j] = (dp[i][j - 1] + val) % M;
                }
            }
        }
        return dp[n][k];
    }
}

 */