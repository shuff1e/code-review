package main

import (
	"fmt"
	"strconv"
)

/*
一个式子，可以分成几个层面来看。比如1 + 2 * 3，我们看它是个算式，
计算机看它，那就是个字符串，所以首先必须把它拆分成计算机可以操作的数据单元，就是Tokenize。
比如1 2 3是操作数，+ 和*是操作符。但是这还不够，算式有优先级之分，先算乘除，后算加减，
也就是算式这种人类描述数学式子的语言，有其自身的文法，所以对于一个算式，
我们还得对这个式子再做分析，就是Parser。
人类发明的语言，计算机分析起来麻烦点，因为计算机处理字符串是从左到右流式的，不像人，先看看后面再看看前面都可以。


平时我们习惯将表达式写成 (1 + 2) * (3 + 4)，加减乘除等运算符写在中间，因此称呼为中缀表达式。
而波兰表达式的写法为 (* (+ 1 2) (+ 3 4))，将运算符写在前面，因而也称为前缀表达式。
逆波兰表达式的写法为 ((1 2 +) (3 4 +) *)，将运算符写在后面，因而也称为后缀表达式。
波兰表达式和逆波兰表达式有个好处，就算将圆括号去掉也没有歧义。
上述的波兰表达式去掉圆括号，变为 * + 1 2 + 3 4。逆波兰表达式去掉圆括号，变成 1 2 + 3 4 + * 也是无歧义并可以计算的。
事实上我们通常说的波兰表达式和逆波兰表达式就是去掉圆括号的。
而中缀表达式，假如去掉圆括号，将 (1 + 2) * (3 + 4) 写成 1 + 2 * 3 + 4，就改变原来意思了。

波兰表达式（前缀表达式），实际是抽象语法树的表示方式，比如中缀 (1 + 2) * (3 + 4) 编译时转成的抽象语法树为
     *
  /    \
 +      +
/ \    / \
1  2  3   4
这个操作符就是根节点，操作数为左右子节点。我们将这棵树用符号表达出来，可以写成 (* (+ 1 2) (+ 3 4))。

至于逆波兰表示式，可用栈进行计算，天生适合于基于栈的语言。
遇到数字就将数字压栈，遇到操作符，就将栈顶的两个元素取出计算，将计算结果再压入栈。

*/

/*
前缀、中缀、后缀表达式

它们都是对表达式的记法，因此也被称为前缀记法、中缀记法和后缀记法。它们之间的区别在于运算符相对与操作数的位置不同：前缀表达式的运算符位于与其相关的操作数之前；中缀和后缀同理。

举例：
(3 + 4) × 5 - 6 就是中缀表达式
- × + 3 4 5 6 前缀表达式
3 4 + 5 × 6 - 后缀表达式

中缀表达式（中缀记法）
中缀表达式是一种通用的算术或逻辑公式表示方法，操作符以中缀形式处于操作数的中间。中缀表达式是人们常用的算术表示方法。
虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。对计算机来说，计算前缀或后缀表达式的值非常简单。

前缀表达式（前缀记法、波兰式）
前缀表达式的运算符位于操作数之前。

前缀表达式的计算机求值：
从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。
例如前缀表达式“- × + 3 4 5 6”：
(1) 从右至左扫描，将6、5、4、3压入堆栈；
(2) 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈；
(3) 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈；
(4) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。
可以看出，用计算机计算前缀表达式的值是很容易的。

后缀表达式（后缀记法、逆波兰式）
后缀表达式与前缀表达式类似，只是运算符位于操作数之后。

后缀表达式的计算机求值：
与前缀表达式类似，只是顺序是从左至右：
从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。
例如后缀表达式“3 4 + 5 × 6 -”：
(1) 从左至右扫描，将3和4压入堆栈；
(2) 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；
(3) 将5入栈；
(4) 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
(5) 将6入栈；
(6) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。
 */

/*

将中缀表达式转换为前缀表达式：
遵循以下步骤：
(1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；
(2) 从右至左扫描中缀表达式；
(3) 遇到操作数时，将其压入S2；
(4) 遇到运算符时，比较其与S1栈顶运算符的优先级：
(4-1) 如果S1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈；
(4-2) 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入S1；
(4-3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；
(5) 遇到括号时：
(5-1) 如果是右括号“)”，则直接压入S1；
(5-2) 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃；
(6) 重复步骤(2)至(5)，直到表达式的最左边；
(7) 将S1中剩余的运算符依次弹出并压入S2；
(8) 依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。
例如，将中缀表达式“1+((2+3)×4)-5”转换为前缀表达式的过程如下：
扫描到的元素								S2(栈底->栈顶)	S1 (栈底->栈顶)	说明
5	5	    							空	数字，直接入栈
-	5	    							-	S1为空，运算符直接入栈
)	5									- )	右括号直接入栈
4	5 4									- )	数字直接入栈
×	5 4									- ) ×	S1栈顶是右括号，直接入栈
)	5 4									- ) × )	右括号直接入栈
3	5 4 3								- ) × )	数字
+	5 4 3								- ) × ) +	S1栈顶是右括号，直接入栈
2	5 4 3 2								- ) × ) +	数字
(	5 4 3 2 +							- ) ×	左括号，弹出运算符直至遇到右括号
(	5 4 3 2 + ×							-	同上
+	5 4 3 2 + ×							- +	优先级与-相同，入栈
1	5 4 3 2 + × 1						- +	数字
到达最左端	5 4 3 2 + × 1 + -			空	S1中剩余的运算符

因此结果为“- + 1 × + 2 3 4 5”。
 */

/*

将中缀表达式转换为后缀表达式：
与转换为前缀表达式相似，遵循以下步骤：
(1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；
(2) 从左至右扫描中缀表达式；
(3) 遇到操作数时，将其压入S2；
(4) 遇到运算符时，比较其与S1栈顶运算符的优先级：
(4-1) 如果S1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
(4-2) 否则，若优先级比栈顶运算符的高，也将运算符压入S1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）；
(4-3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；
(5) 遇到括号时：
(5-1) 如果是左括号“(”，则直接压入S1；
(5-2) 如果是右括号“)”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到左括号为止，此时将这一对括号丢弃；
(6) 重复步骤(2)至(5)，直到表达式的最右边；
(7) 将S1中剩余的运算符依次弹出并压入S2；
(8) 依次弹出S2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）。

例如，将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下：
扫描到的元素						S2(栈底->栈顶)	S1 (栈底->栈顶)	说明
1	1							空	数字，直接入栈
+	1							+	S1为空，运算符直接入栈
(	1							+ (	左括号，直接入栈
(	1							+ ( (	同上
2	1 2							+ ( (	数字
+	1 2							+ ( ( +	S1栈顶为左括号，运算符直接入栈
3	1 2 3						+ ( ( +	数字
)	1 2 3 +						+ (	右括号，弹出运算符直至遇到左括号
×	1 2 3 +						+ ( ×	S1栈顶为左括号，运算符直接入栈
4	1 2 3 + 4					+ ( ×	数字
)	1 2 3 + 4 ×					+	右括号，弹出运算符直至遇到左括号
-	1 2 3 + 4 × +				-	-与+优先级相同，因此弹出+，再压入-
5	1 2 3 + 4 × + 5				-	数字
到达最右端	1 2 3 + 4 × + 5 -	空	S1中剩余的运算符

因此结果为“1 2 3 + 4 × + 5 -”（注意需要逆序输出）。

 */



/*
150. 逆波兰表达式求值
根据 逆波兰表示法，求表达式的值。

有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例 1：

输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：

输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：

输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
输出: 22
解释:
该算式转化为常见的中缀算术表达式为：
((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22

逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。
 */

// A：输入: ["2", "1", "+", "3", "*"]
// 输出: 9
// 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

func main() {
	tokens := []string{"4","13","5","/","+"}
	fmt.Println(evalRPN(tokens))
}


// (3 + 4) / 5 - 6 就是中缀表达式
// - / + 3 4 5 6 前缀表达式
// 3 4 + 5 / 6 - 后缀表达式

// 前缀表达式，是op1 operation op2
// 后缀表达式，是op2 operation op1

func evalRPN(tokens []string) int {
	stack := []int{}
	for i := 0;i<len(tokens);i++ {
		if v,err := strconv.Atoi(tokens[i]);err == nil {
			// push
			stack = append(stack,v)
		} else {
			// pop
			op1 := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			// pop
			op2 := stack[len(stack)-1]
			stack = stack[:len(stack)-1]

			result := 0
			switch tokens[i] {
			case "*":
				result = op2 * op1
			case "/":
				result = op2 / op1
			case "+":
				result = op2 + op1
			case "-":
				result = op2 - op1
			}
			stack = append(stack,result)
		}
	}
	return stack[0]
}