package Catalan_number

// 一个栈(无穷大)的[进栈]序列为1，2，3，…，n，有多少个不同的[出栈]序列?

//A2：对于每一个数来说，必须进栈一次、出栈一次。我们把[进栈]设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位[二进制数]。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于[出栈]的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。
//在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。
//不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。
//反过来，任何一个由n+1个0和n-1个1组成的2n位[二进制数]，由于0的个数多2个，2n为[偶数]，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。
//因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。
//显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n+1)=c(2n,n)/(n+1)=h(n)。

//Q1：有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？
//A1：将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈。

//Q2：12个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？
//A2：我们先把这12个人从低到高排列,然后,选择6个人排在第一排,那么剩下的6个肯定是在第二排.

//用0表示对应的人在第一排,用1表示对应的人在第二排,那么含有6个0,6个1的序列,就对应一种方案.

//比如1 2 3 4 5 6 7 8 9 10 11 12
//000000111111就对应着
//第一排：0 1 2 3 4 5
//第二排：6 7 8 9 10 11

//1 2 3 4 5 6 7 8 9 10 11 12
//010101010101就对应着
//第一排：0 2 4 6 8 10
//第二排：1 3 5 7 9 11

//类似于ctci9.5中的打印n对括号的有效组合，何时可以使用左括号呢？何时可以使用右括号呢？
//(1)左括号：只要左括号没有用完，就可以插入左括号
//(2)右括号：只要不造成语法错误，就可以使用右括号。何时会出现语法错误？如果右括号比左括号还多，就会出现语法错误。

//Q3：n对括号的有效组合数